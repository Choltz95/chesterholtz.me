<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chester Holtz</title>
    <description>Chester Holtz&#39;s website.  I am an aspiring scientist.
</description>
    <link>http://chesterholtz.me/</link>
    <atom:link href="http://chesterholtz.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 14 Jul 2015 23:12:16 -0400</pubDate>
    <lastBuildDate>Tue, 14 Jul 2015 23:12:16 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Distrbuted computation with a raspberry pi cluster(1)</title>
        <description>&lt;p&gt;I have had a great deal of fun reading about the many adventures of the physicist &lt;a href=&quot;https://en.wikipedia.org/wiki/Richard_Feynman&quot;&gt;Richard Feynman&lt;/a&gt;. I read his semi-autobiography &lt;em&gt;Surely You&amp;rsquo;re Joking Mr. Feynman!&lt;/em&gt; as a kid, watched his video series on computer heuristics as a freshman taking a class on organization of computer systems, and found his physics notes to be invaluable while taking an introductory physics series. Recently I have also been reading about his collaboration with the great computer scientist &lt;a href=&quot;https://en.wikipedia.org/wiki/Danny_Hillis&quot;&gt;Dany Hillis&lt;/a&gt; - coincidentally advised by 3 other famous computer scientists - on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Connection_Machine&quot;&gt;Connection Machine&lt;/a&gt; - a parallel arangement of multiple supercomputers. Additionally, one of my mentors at The University of Rochester just retired, and while browsing his library, I found that he had worked on the development of software for the &lt;a href=&quot;https://en.wikipedia.org/wiki/BBN_Butterfly&quot;&gt;BBN Butterfly Processor&lt;/a&gt; - one of the largest parallel computers of the 1980s. These factors all served to exite my interest in parallel computation and distributed systems. Although it is a topic I am most interested in, I will most likely not be taking a class on the topic, but also want some sort of foundation in the subject. &lt;/p&gt;

&lt;p&gt;In this project series I will be experimenting with various distributed algorithms for doing various things over a network. I will be examining the efficiency of computation which can be divided among multiple processors. Algorithms which I will be looking at include the canonical mergesort, matrix arithmetic, plotting a Delaunay Triangulation, and others.&lt;/p&gt;

&lt;p&gt;For testing and comparing the parallelized and single-processor approaches for various aglorithms, I primarily consider one important metric: average computation time. These statistics are gathered during run time by using the high precision timers in the C++ chrono library, which allows the collection of timing data accurate on the order of nanoseconds. Testing itself is performed on three raspberry Pi B+ computers. These machines feature an 700 MHz single-core ARM1176JZF-S processor with 144 KB of Cache and 512 MB of RAM. The complete code for this project can be found on on my &lt;a href=&quot;https://github.com/Choltz95/distributedRPI&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Merge sort is a classic sorting algorithm used to introduce the divide and conquer algorithm design paradigm. As such, it is known to parallelize well.&lt;/p&gt;

&lt;p&gt;Recursively, mergesort processes an unsorted list of numbers by dividing the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted). It then repeatedly merges sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list. The following is a short walkthrough of the server-side code written for a distributed mergesort and the results of the comparison.&lt;/p&gt;

&lt;p&gt;An general example is given below with some merge and split steps skipped to conserve space. 
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
Start       : 3--4--2--1--7--5--8--9--0--6
Split       : 3--4--2--1--7  5--8--9--0--6
Split       : 3  4  2  1  7  5  8  9  0  6
Merge       : 3--4  1--2  5--7  8--9  0--6
Merge       : 1--2--3--4  5--7--8--9  0--6
Merge       : 0--1--2--3--4--5--6--7--8--9
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;I partition my initial unsorted array into n subarrays of equal size on the server. These subarrays will be passed to individual raspberry pi nodes to be sorted before being merged on the server. My breakarray() funtion intuitively takes the initial unsorted array and the number of processors on the network.
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
def breakarray(array, n): 
    sectionlength = len(array)/n    #length of each section 
    result = [] 
    for i in range(n):
        if i &amp;lt; n - 1:
            result.append( array[ i * sectionlength : (i+1) * sectionlength ] )
        #include all remaining elements for the last section 
        else:
            result.append( array[ i * sectionlength : ] )&lt;br&gt;
    return result
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Furthermore, setting up a simple network is quite simple. I make use of Python&amp;rsquo;s socket module to do this. I first provide host and port parameters and create an inet, streaming socket before binding the socket to local host and port.
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
HOST = &amp;#39;&amp;#39;
PORT = 50007 
s = socket.socket(socket.AF&lt;em&gt;INET, socket.SOCK&lt;/em&gt;STREAM) 
print &amp;#39;[DEBUG] Socket created&amp;#39;
s.setsockopt(socket.SOL&lt;em&gt;SOCKET, socket.SO&lt;/em&gt;REUSEADDR, 1) 
try:
    s.bind((HOST, PORT))
except socket.error as msg:
    print &amp;#39;[ERROR] Bind failed. Error Code : &amp;#39; + str(msg[0]) + &amp;#39; Message &amp;#39; + msg&lt;a href=&quot;https://en.wikipedia.org/wiki/Richard_Feynman&quot;&gt;1&lt;/a&gt;
    sys.exit()
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Finally, I send and recieve the data in 4KB size chunks. Once sorted, the client sends its assigned subaray back to the server to be merged.
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
for i in range(procno - 1): # Converts array section into string to be sent
    arraystring = repr(sections[i+1]) 
    conn.sendto(arraystring, addr_list[i])  # Sends array string 
print &amp;#39;[DEBUG] Data sent, sorting array...&amp;#39;
&lt;/pre&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
# Receives sorted sections from each client
for i in range(procno - 1):
    arraystring = &#39;&#39; 
    print &#39;[DEBUG] Receiving data from clients...&#39; 
    while 1:
        data = conn.recv(4096)  # Receives data in chunks 
        arraystring += data # Adds data to array string 
        if &#39;]&#39; in data: # When end of data is received
            break

    print &#39;[DEBUG] Data received, merging arrays...&#39;    
    array = ms.merge(array, eval(arraystring))  # Merges current array with section from client
    print &#39;[DEBUG] Arrays merged.&#39;
&lt;/pre&gt;

&lt;p&gt;Tests were preformed on list lengths ranging from 1,000 to 1,000,000, and in all cases, the distributed set up outpreformed the single-node settup by factor seemingly proportional to the number of nodes I distributed the unsorted list accross. Sample output are given below:&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
$ sudo python server.py 3 10000
[DEBUG] Waiting for client...
[DEBUG] connected to 192.168.1.2:50007
[DEBUG] connected to 192.168.1.3:50007
[DEBUG] Data sent, sorting array...
[DEBUG] Array sorted.
[DEBUG] Receiving data from clients...
[DEBUG] Data Recieved, merging arrays...
[DEBUG] Arrays merged.
[DEBUG] Time taken to sort: 21.223145 seconds.
&lt;/pre&gt;

&lt;p&gt;This concludes the first part of this project series. Expect more updates comming soon.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://chesterholtz.me/blog/post/rpi_distributed_1</link>
        <guid isPermaLink="true">http://chesterholtz.me/blog/post/rpi_distributed_1</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Introduction and personal statement</title>
        <description>&lt;p&gt;I am a junior at &lt;a href=&quot;http://www.hajim.rochester.edu/&quot;&gt;The University of Rochester Hajim School of Engineering&lt;/a&gt; studying computer science and mathematics. I am interested in investing myself in projects which present challenges relating several sciences or technologies. I am currently seeking a summer internship, research position, or job in computer science.&lt;/p&gt;

&lt;p&gt;I would like to continue a path of research in big data analysis and in developing software to interface with real-world data. Currently I am working on writting real time mapping visualization of occurances of global chaotic events. &lt;/p&gt;

&lt;p&gt;Along with computer science, I also have a love of physics and mathematics and I am especially interested in the application of game theory to political science. &lt;/p&gt;

&lt;p&gt;My previous website served as a portfolio to demonstrate my competence in several web technologies and frameworks, but grew to be quite bloated and unecessarily flashy. I decided to focus less on the website itself and instead to make a website which contained deep and meaningful content.&lt;/p&gt;

&lt;p&gt;Since I am not much of a writter, updates to the blog portion of this website will not be consistent, and will most likely be composed of technical reports of projects and research I am involved in. I definitely do not expect this website to be visited frequently, and am primarily utilizing this blog to organize my thoughts and keep a well layed out map of projects and ideas I find interesting.&lt;/p&gt;

&lt;p&gt;On my previous website, I had a page devoted to my five favorite books. They are:   &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&quot;&gt;Gödel, Escher, Bach: An Eternal Golden Braid&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Do_Androids_Dream_of_Electric_Sheep%3F&quot;&gt;Do Androids Dream of Electric Sheep?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dune_(novel)&quot;&gt;Dune&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Surely_You%27re_Joking,_Mr._Feynman!&quot;&gt;Surely You&amp;rsquo;re Joking, Mr. Feynman!: Adventures of a Curious Character&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Lord_of_the_Rings&quot;&gt;Lord of the Rings&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://chesterholtz.me/blog/post/personal_statement</link>
        <guid isPermaLink="true">http://chesterholtz.me/blog/post/personal_statement</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Visualizing the genetic diversity of finite populations</title>
        <description>&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Moran_process&quot;&gt;Moran Process&lt;/a&gt; is a simple stochastic process used to describe finite populations[wikipedia].
I created a simply visualization of fundamental properties of an evolving population. Since color can be represented as a 6-digit hexadecimal number, we can generalize color to be representative of an agents DNA, and preform operations representing mutation, inheritence, selection, and crossover by altering the color of the agent.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://chesterholtz.me/blog/post/finite_population_visualization</link>
        <guid isPermaLink="true">http://chesterholtz.me/blog/post/finite_population_visualization</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Evis - event driven cartography with the GDELT dataset</title>
        <description>&lt;p&gt;The progress on this project has been relatively slow, since i have been working on this project inconsistently. My interest in analysis of large data sets is due to my involvement in Professor Jiebo Luo&amp;rsquo;s &lt;a href=&quot;http://www.cs.rochester.edu/u/jluo/&quot;&gt;VIStA (Visual Intelligence &amp;amp; Social Multimedia Analytics) Research Group&lt;/a&gt; as a research assistant. Currently, I am developing a web interface for the &lt;a href=&quot;http://gdeltproject.org/&quot;&gt;gdelt (Global Database of Events, Language, and Tone) dataset&lt;/a&gt; while also preforming analysis and rendering a visualization of real-time chaotic events - natural disasters, violence against civilians, etc. - in the world. &lt;/p&gt;

&lt;p&gt;Gdelt is a continuously updated repository which gathers events from around the world since 1979 and indexes them according to various metrics. Every 15 minutes, GDELT scrapes various news sources for relavent data and current events to update its database with entries containing locations, times, descriptions and other relavent data.&lt;/p&gt;

&lt;p&gt;In testing, I use Python&amp;rsquo;s matplotlib module with the basemap toolkit to plot data in real time and to literally draw correlations between events. Recently, GDELT was uploaded to google&amp;rsquo;s bigquery which allows me to parse and analize over a quarter million events for free in seconds.&lt;/p&gt;

&lt;p&gt;For the final rendition, I plan writting the application in javascript to be renderable in a browser.&lt;/p&gt;

&lt;p&gt;The code is hosted on my &lt;a href=&quot;https://github.com/Choltz95/Evis&quot;&gt;github&lt;/a&gt;, but is probably a little behind the current version as I am working on this project in a cloud vm.&lt;/p&gt;

&lt;p&gt;An example demonstrating the power of google bigquery is provided below (taken from google&amp;rsquo;s cloud platform blog): when I run the following sql query against a databse containing a quarter billion rows a set of 37 entries representing the most significant events of the last 37 years is returned in only a few seconds. From there, I can download the data as a json file and parse it, drawing data onto a map to be interacted with, or simply examined.
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT Year, Actor1Name, Actor2Name, Count FROM (
SELECT Actor1Name, Actor2Name, Year, COUNT(*) Count, RANK() OVER(PARTITION BY YEAR ORDER BY Count DESC) rank
FROM 
(SELECT Actor1Name, Actor2Name,  Year FROM [gdelt-bq:full.events] WHERE Actor1Name &amp;lt; Actor2Name and Actor1CountryCode != &amp;#39;&amp;#39; and Actor2CountryCode != &amp;#39;&amp;#39; and Actor1CountryCode!=Actor2CountryCode),  (SELECT Actor2Name Actor1Name, Actor1Name Actor2Name, Year FROM [gdelt-bq:full.events] WHERE Actor1Name &amp;gt; Actor2Name  and Actor1CountryCode != &amp;#39;&amp;#39; and Actor2CountryCode != &amp;#39;&amp;#39; and Actor1CountryCode!=Actor2CountryCode),
WHERE Actor1Name IS NOT null
AND Actor2Name IS NOT null
GROUP EACH BY 1, 2, 3
HAVING Count &amp;gt; 100
)
WHERE rank=1
ORDER BY Year
&lt;/pre&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
{&quot;Year&quot;:&quot;1979&quot;,&quot;Actor1Name&quot;:&quot;CHINA&quot;,&quot;Actor2Name&quot;:&quot;VIETNAM&quot;,&quot;Count&quot;:&quot;2668&quot;}
{&quot;Year&quot;:&quot;1980&quot;,&quot;Actor1Name&quot;:&quot;AFGHANISTAN&quot;,&quot;Actor2Name&quot;:&quot;RUSSIA&quot;,&quot;Count&quot;:&quot;3899&quot;}
{&quot;Year&quot;:&quot;1981&quot;,&quot;Actor1Name&quot;:&quot;RUSSIA&quot;,&quot;Actor2Name&quot;:&quot;UNITED STATES&quot;,&quot;Count&quot;:&quot;3079&quot;}
{&quot;Year&quot;:&quot;1982&quot;,&quot;Actor1Name&quot;:&quot;ISRAEL&quot;,&quot;Actor2Name&quot;:&quot;LEBANON&quot;,&quot;Count&quot;:&quot;4253&quot;}
{&quot;Year&quot;:&quot;1983&quot;,&quot;Actor1Name&quot;:&quot;ISRAEL&quot;,&quot;Actor2Name&quot;:&quot;LEBANON&quot;,&quot;Count&quot;:&quot;4955&quot;}
...
{&quot;Year&quot;:&quot;2012&quot;,&quot;Actor1Name&quot;:&quot;CHINA&quot;,&quot;Actor2Name&quot;:&quot;UNITED STATES&quot;,&quot;Count&quot;:&quot;42231&quot;}
{&quot;Year&quot;:&quot;2013&quot;,&quot;Actor1Name&quot;:&quot;RUSSIA&quot;,&quot;Actor2Name&quot;:&quot;UNITED STATES&quot;,&quot;Count&quot;:&quot;61191&quot;}
{&quot;Year&quot;:&quot;2014&quot;,&quot;Actor1Name&quot;:&quot;RUSSIA&quot;,&quot;Actor2Name&quot;:&quot;UKRAINE&quot;,&quot;Count&quot;:&quot;120995&quot;}
{&quot;Year&quot;:&quot;2015&quot;,&quot;Actor1Name&quot;:&quot;RUSSIA&quot;,&quot;Actor2Name&quot;:&quot;UKRAINE&quot;,&quot;Count&quot;:&quot;39236&quot;}
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/map.png&quot; alt=&quot;alt text&quot; title=&quot;Example map&quot;&gt;&lt;/p&gt;

&lt;p&gt;The biggest issue encountered is the free data limit. Since the goal for this project involves a real-time component, it is necessary to requery data from gdelt every update.  &lt;/p&gt;
</description>
        <pubDate>Wed, 08 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://chesterholtz.me/blog/post/event_driven_cartography</link>
        <guid isPermaLink="true">http://chesterholtz.me/blog/post/event_driven_cartography</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
      <item>
        <title>Micro Lisp interpreter and garbage collection</title>
        <description>&lt;p&gt;This past semester I have been rereading Gerald Sussman&amp;rsquo;s popular text: Structure and Interpretation of Computer Programs. I have worked on a lisp interpreter in JavaScript in the past inspired by the implementations of &lt;a href=&quot;https://en.wikipedia.org/wiki/Peter_Norvig&quot;&gt;Peter Norvig&lt;/a&gt; and &lt;a href=&quot;https://github.com/maryrosecook&quot;&gt;Mary Rose Cook&lt;/a&gt; - one that followed the 10 rules of &lt;a href=&quot;https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)&quot;&gt;John McCarthy&lt;/a&gt; detailed in his paper &lt;a href=&quot;http://www.cse.sc.edu/%7Emgv/csce330f13/micromanualLISP.pdf&quot;&gt;A Micro-Manual for Lisp - Not the whole Truth&lt;/a&gt;. This implementation is what will be discussed in this first blog post. In a future post, I may go into detail regarding my eventual reimplimintation of Micro Lisp and several garbage collection algorithms in C++.&lt;/p&gt;

&lt;p&gt;LISP is family of programming languages first conceived in 1959 by John McCarthy. In LISP, computation is expressed as a function of one or more objects. Objects can be other functions, data types, or data structures. Despite its age, derivations of LISP such as Common Lisp, Clojure, and Scheme are the most commonly used programming languages for AI research and many other applications.&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;http://github.com/Choltz95/microlispjs&quot;&gt;Micro Lisp&lt;/a&gt; is an interpreter that supports function invocation, lambdas, lets, ifs, numbers, strings, a few JavaScript library functions, and lists. I wrote it over a weekend in about 150 lines of JavaScript, and also included a number of simple and more complex test cases. The code for the project can be found on my &lt;a href=&quot;http://github.com/Choltz95/microlispjs&quot;&gt;github&lt;/a&gt;, while one can test a deployed version &lt;a href=&quot;http://littlelispjs.divshot.io/&quot;&gt;here&lt;/a&gt;. It is recommended, however, to clone yourself a copy directly from the repository and open index.html in your browser locally.&lt;/p&gt;

&lt;p&gt;There are two important parts to consider when writting an interpreter: &lt;code&gt;parsing&lt;/code&gt; and &lt;code&gt;evaluation&lt;/code&gt;. When we parse a Lisp expression, we take the code typed by the programmer and transform  it into a representation that we can traverse and evaluate. Evaluation refers to the procedure of processing this structure according to the symantic rules of Lisp and returning a result.&lt;/p&gt;

&lt;p&gt;Traditionally, the parsing process is separated into two parts: the &lt;code&gt;tokenizer&lt;/code&gt; and the &lt;code&gt;AST assembler&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The tokenizer demarcates a string of input characters into &lt;code&gt;tokens&lt;/code&gt; before passing them on to be assembled into an AST. For Micro Lisp, tokens consist of parentheses, symbols, and numbers.&lt;/p&gt;

&lt;p&gt;We tokenize by taking advantage of JavaScript&amp;rsquo;s &lt;code&gt;replace()&lt;/code&gt; and &lt;code&gt;split()&lt;/code&gt; functions to take a character string input, add whitespace around each parentheses, and split the result by whitespace to get a JavaScript list of tokens. tokenize() is given below.&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;var tokenize = function(input) {
   return input.replace(/\(/g, &#39; ( &#39;)
               .replace(/\)/g, &#39; ) &#39;)
               .trim()
               .split(/\s+/);
 };
&lt;/pre&gt;

&lt;p&gt;An AST, or Abstract Syntax Tree is a representation of the structure of code written in a language. The tree is abstract since each node of this tree represents a construct in code, but some elements of the code may be ommitted, i.e. parentheses in our case. Since the inherint syntax structure of a lisp symbolic expression - &amp;rsquo;S-Expression&amp;rsquo; - is representative of an AST, this task is quite simple. An S-Expression can simply be defined inductively as an atom, or an expression (x y) where x and y can be S-Expressions themselves.&lt;/p&gt;

&lt;p&gt;Atoms are collections of letters, digits or other characters not otherwise defined in the micro-lisp language. furthermore, lists consist of a left parenthesis followed by a head - or &lt;code&gt;CAR&lt;/code&gt; - and a tail - a &lt;code&gt;CDR&lt;/code&gt;. Lists always end with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Parsing a Lisp S-Expression is quite simple. First, parse() is called with a character string input representing the program. to be interpreted. We then tokenize this input to get a list of tokens and pass this list into read_from to assemble the AST. We shift through elements of the list one at a time. If the token at the 0th indice is a &amp;rsquo;(&amp;rsquo;, we instantiate a list of S-Expressions and recursively add to that list until we encounter a matching &amp;rsquo;)&amp;rsquo;. The parse() logic is given below.&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;function parse(input) {
  return read_from(tokenize(input));
}

function read_from(tokens) {
    if (tokens.length == 0) {
        throw &#39;unexpected EOF&#39;;
    }

    var token = tokens.shift();
    if (&#39;(&#39; == token) {
        var L = [];
        while (tokens[0] != &#39;)&#39;) {
            L.push(read_from(tokens));
        }
        tokens.shift();
        return L;
    } else {
        return atom(token);
      }
}
&lt;/pre&gt;

&lt;p&gt;Below is an example of input, and the resulting output of parsing the Lisp S-Expression (hello (hello world)).&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;&gt;tokenize(&#39;(hello (hello world))&#39;)
[&quot;(&quot;, &quot;hello&quot;, &quot;(&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;)&quot;, &quot;)&quot;]
&lt;/pre&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;&gt;parse(&#39;(hello (hello world))&#39;)
[&quot;hello&quot;, [&quot;hello&quot;, &quot;world&quot;]]
&lt;/pre&gt;

&lt;p&gt;Evaluation is the most complex part of the interpretation process. When we evaluate, we look at an expression and check its value according to the &lt;code&gt;env&lt;/code&gt; environment - implemented as a JS Dictionary. An environment is simply a mapping from a variable name to its value. &lt;/p&gt;

&lt;p&gt;In code, we impliment a finite number of predefined functions in the global environment as&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
var Operations = {
&#39;+&#39;       : function(a, b) { return a + b; },
&#39;-&#39;       : function(a, b) { return a - b;},
&#39;*&#39;       : function(a, b) { return a * b; },
&#39;/&#39;       : function(a, b) { return a / b; },
&#39;&lt;&#39;       : function(a, b) { return a &lt; b; },
&#39;&gt;&#39;       : function(a, b) { return a &gt; b; },
&#39;&lt;=&#39;      : function(a, b) { return a &lt;= b; },
&#39;&gt;=&#39;      : function(a, b) { return a &gt;= b; },
&#39;=&#39;       : function(a, b) { return a == b; },
&#39;or&#39;      : function(a,b)  { return a||b;   },
&#39;cons&#39;    : function(a, b) { return [a].concat(b); },
&#39;car&#39;     : function(a)    { return (a.length !==0) ? a[0] : null; },
&#39;cdr&#39;     : function(a)    { return (a.length&gt;1) ? a.slice(1) : null; },
&#39;list&#39;    : function()     { return Array.prototype.slice.call(arguments); },
};
&lt;/pre&gt;

&lt;p&gt;and impliment a local environment when the interpreter parses a &lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;def&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;When we evaluate an expression, we check the expression&amp;rsquo;s function and arguments. If an expression is prefixed by a &lt;code&gt;&amp;#39;&lt;/code&gt;, or the function being applied is the string QUOTE, we return the expression, or arguments literally and do not evaluate. The forms necessary for a lisp to be considered a Micro Lisp are given as the rules below where expressions are denoted e or a, functions as f and variables as v.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;QUOTE - The value of (QUOTE A) is A&lt;/li&gt;
&lt;li&gt;CAR - The value of (CAR e) is the first element of e where e is defined as a non-empty list. i.e. (CAR (QUOTE (A B))) returns A&lt;/li&gt;
&lt;li&gt;CDR - The value of (CDR e) is the list of remaining elements of e when CAR of e is removed, where e is defined above. ie (CDR (QUOTE (A B))) returns B.&lt;/li&gt;
&lt;li&gt;CONS - The value of (CONS e1 e2) is the list that results from prefixing e1 onto e2. Thus, (CONS (QUOTE A) (QUOTE B)) returns the list (A B).&lt;/li&gt;
&lt;li&gt;EQUAL - The value of (EQUAL e1 e2) is true if e1 = e2 and false if otherwise. (EQUAL 1 2) returns false.&lt;/li&gt;
&lt;li&gt;ATOM - The value of (ATOM e1) is true if e1 is an atom and false if otherwise. (ATOM)&lt;/li&gt;
&lt;li&gt;COND - The value of (COND(e1 e1) &amp;hellip; (pn en)) is the value of ei, where pi is the the first ofthe p&amp;rsquo;s whose value is not NIL.&lt;/li&gt;
&lt;li&gt;DEFINE - The DEFINE function maps a variable to the given expression.&lt;/li&gt;
&lt;li&gt;LAMBDA - Lambda is a construct in the Micro-Lisp language which allows for the definition
of anonymous functions.&lt;/li&gt;
&lt;li&gt;Operators - We also provide definitions for traditional boolean ( =, &amp;gt;, ≥, &amp;lt;, ≤&amp;hellip;) and
arithmetic operators (+, −, ∗, /&amp;hellip;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An example of the case &amp;lsquo;DEFINE&amp;rsquo; is given below:&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
case &quot;DEFINE&quot;:
    [_, variable, exp] = x;
    env.set(variable, evaluate(exp, env));
&lt;/pre&gt;

&lt;p&gt;Here, we switch over the first token x[0], and assuming that the next token x[1] is an atom, we set a new indice in the local environment to the variable name &amp;#39;variable&amp;rsquo; and its value to the argument expression (x[2])  evaluated with respect to the global enviornment.&lt;/p&gt;

&lt;p&gt;With these rules in place, we have a robust and portable lisp that we can use to program anywhere in with a browser. It becomes quite easy to define our own, more complex functions. By querying the help function by typing &amp;ldquo;sample&amp;rdquo; into the interpreter prompt, a number of different examples are presented with the most advanced being application of the fibonacci function onto a range of numbers.&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;&gt; (define range (lambda (a b) (cond (= a b) (quote ()) (cons a (range (+ a 1) b)))))
null
&gt; (define map (lambda (f xs) (cond (= xs nil) nil (cons (f (car xs)) (map f (cdr xs))))))
null
&gt; (map (lambda (x) (+ x 1)) (range 0 10))
(1 2 3 4 5 6 7 8 9 10 null)
&gt; (map (lambda (x) (fac x)) (range 0 10))
(1 1 2 6 24 120 720 5040 40320 362880 null)
&gt; (define fib (lambda (n) (cond (or (= n 0) (= n 1)) 1 (+ (fib (- n 1)) (fib (- n 2))))))
null
&gt; (map (lambda (x) (fib x)) (range 0 10))
(1 1 2 3 5 8 13 21 34 55 null)&lt;/pre&gt;

&lt;p&gt;Originally I had intended to also discuss preforming garbage collection on list based system in this post and implementing a turtle graphics module utilizing HTML5 canvas, but I think I will visit those topics at a later time. &lt;/p&gt;
</description>
        <pubDate>Tue, 07 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://chesterholtz.me/blog/post/micro_lisp_interpreter</link>
        <guid isPermaLink="true">http://chesterholtz.me/blog/post/micro_lisp_interpreter</guid>
        
        
        <category>uncategorized</category>
        
      </item>
    
  </channel>
</rss>
